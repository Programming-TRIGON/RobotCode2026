package frc.trigon.robot.misc.shootingphysics;

import java.io.*;

/**
 * 3D shooting lookup table - NO NaN values (filled during generation).
 * Uses trilinear interpolation on complete grid.
 * <p>
 * Memory: ~1-2 MB, Loading: ~50-100ms, Lookup: ~0.005-0.01 ms
 * <p>
 * Generated by Python calibration system.
 * DO NOT EDIT MANUALLY.
 */
public class ShootingLookupTable3D {
    private static int DISTANCE_SIZE;
    private static int RADIAL_SIZE;
    private static int TANGENTIAL_SIZE;
    private static double DISTANCE_MIN, DISTANCE_MAX, DISTANCE_STEP;
    private static double RADIAL_MIN, RADIAL_MAX, VELOCITY_STEP;
    private static double TANGENTIAL_MIN, TANGENTIAL_MAX;

    private static double[] VELOCITY_DATA;
    private static double[] PITCH_DATA;
    private static double[] YAW_DATA;
    private static boolean loaded = false;

    public static void init() {
        try {
            loadFromFile(ShootingCalculationsConstants.SHOOTING_LOOKUP_TABLE_FILEPATH);
        } catch (IOException e) {
            e.printStackTrace();
            throw new RuntimeException("Failed to load ShootingLookupTable3D!");
        }
    }

    public static void loadFromFile(String filepath) throws IOException {
        if (loaded) {
            System.out.println("ShootingLookupTable3D already loaded, skipping");
            return;
        }

        long startTime = System.currentTimeMillis();

        File file = new File(filepath);
        if (!file.exists()) {
            throw new IOException("LUT file not found: " + filepath);
        }

        System.out.println("Loading ShootingLookupTable3D from: " + filepath);
        System.out.println("  File size: " + (file.length() / 1024 / 1024) + " MB");

        try (DataInputStream dis = new DataInputStream(new BufferedInputStream(new FileInputStream(file), 65536))) {
            // Read header (big-endian)
            DISTANCE_SIZE = dis.readInt();
            RADIAL_SIZE = dis.readInt();
            TANGENTIAL_SIZE = dis.readInt();
            DISTANCE_MIN = dis.readDouble();
            DISTANCE_MAX = dis.readDouble();
            DISTANCE_STEP = dis.readDouble();
            RADIAL_MIN = dis.readDouble();
            RADIAL_MAX = dis.readDouble();
            VELOCITY_STEP = dis.readDouble();
            TANGENTIAL_MIN = dis.readDouble();
            TANGENTIAL_MAX = TANGENTIAL_MIN + (TANGENTIAL_SIZE - 1) * VELOCITY_STEP;

            int totalSize = DISTANCE_SIZE * RADIAL_SIZE * TANGENTIAL_SIZE;

            System.out.println("  Grid: " + DISTANCE_SIZE + " × " + RADIAL_SIZE + " × " + TANGENTIAL_SIZE + " = " + totalSize + " elements");

            // Allocate flat arrays
            VELOCITY_DATA = new double[totalSize];
            PITCH_DATA = new double[totalSize];
            YAW_DATA = new double[totalSize];

            // Read data
            for (int i = 0; i < totalSize; i++) VELOCITY_DATA[i] = dis.readDouble();
            for (int i = 0; i < totalSize; i++) PITCH_DATA[i] = dis.readDouble();
            for (int i = 0; i < totalSize; i++) YAW_DATA[i] = dis.readDouble();

            loaded = true;

            long elapsedMs = System.currentTimeMillis() - startTime;
            System.out.println("[SUCCESS] ShootingLookupTable3D loaded in " + elapsedMs + "ms");
            System.out.println("  Memory: " + (totalSize * 3 * 8 / 1024 / 1024) + " MB");
        } catch (IOException e) {
            System.err.println("ERROR loading ShootingLookupTable3D: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    public static boolean isLoaded() {
        return loaded && VELOCITY_DATA != null && VELOCITY_DATA.length > 0;
    }

    private static int index(int d, int r, int t) {
        return d * (RADIAL_SIZE * TANGENTIAL_SIZE) + r * TANGENTIAL_SIZE + t;
    }

    private static double get(double[] data, int d, int r, int t) {
        return data[index(d, r, t)];
    }

    public static double calculateVelocity(double distance, double radialVelocity, double tangentialVelocity) {
        if (!isLoaded()) {
            System.err.println("ERROR: ShootingLookupTable3D not loaded!");
            return 0.0;
        }
        return interpolate(VELOCITY_DATA, distance, radialVelocity, Math.abs(tangentialVelocity));
    }

    public static double calculatePitch(double distance, double radialVelocity, double tangentialVelocity) {
        if (!isLoaded()) {
            System.err.println("ERROR: ShootingLookupTable3D not loaded!");
            return 0.0;
        }
        return interpolate(PITCH_DATA, distance, radialVelocity, Math.abs(tangentialVelocity));
    }

    public static double calculateYaw(double distance, double radialVelocity, double tangentialVelocity) {
        if (!isLoaded()) {
            System.err.println("ERROR: ShootingLookupTable3D not loaded!");
            return 0.0;
        }
        double yaw = interpolate(YAW_DATA, distance, radialVelocity, Math.abs(tangentialVelocity));
        return tangentialVelocity >= 0 ? yaw : -yaw;
    }

    private static double interpolate(double[] data, double distance, double radialVel, double tangentialVel) {
        // Clamp to grid bounds
        distance = Math.max(DISTANCE_MIN, Math.min(distance, DISTANCE_MAX));
        radialVel = Math.max(RADIAL_MIN, Math.min(radialVel, RADIAL_MAX));
        tangentialVel = Math.max(TANGENTIAL_MIN, Math.min(tangentialVel, TANGENTIAL_MAX));

        // Convert to continuous indices
        double distIdx = (distance - DISTANCE_MIN) / DISTANCE_STEP;
        double radIdx = (radialVel - RADIAL_MIN) / VELOCITY_STEP;
        double tanIdx = (tangentialVel - TANGENTIAL_MIN) / VELOCITY_STEP;

        // Find surrounding grid points
        int d0 = (int) Math.floor(distIdx), d1 = Math.min(d0 + 1, DISTANCE_SIZE - 1);
        int r0 = (int) Math.floor(radIdx), r1 = Math.min(r0 + 1, RADIAL_SIZE - 1);
        int t0 = (int) Math.floor(tanIdx), t1 = Math.min(t0 + 1, TANGENTIAL_SIZE - 1);

        // Interpolation weights
        double wd = distIdx - d0, wr = radIdx - r0, wt = tanIdx - t0;

        // Trilinear interpolation - NO NaN (verified in Python)
        double c000 = get(data, d0, r0, t0), c001 = get(data, d0, r0, t1);
        double c010 = get(data, d0, r1, t0), c011 = get(data, d0, r1, t1);
        double c100 = get(data, d1, r0, t0), c101 = get(data, d1, r0, t1);
        double c110 = get(data, d1, r1, t0), c111 = get(data, d1, r1, t1);

        // Interpolate along distance axis
        double c00 = c000 + wd * (c100 - c000), c01 = c001 + wd * (c101 - c001);
        double c10 = c010 + wd * (c110 - c010), c11 = c011 + wd * (c111 - c011);

        // Interpolate along radial axis
        double c0 = c00 + wr * (c10 - c00), c1 = c01 + wr * (c11 - c01);

        // Interpolate along tangential axis
        return c0 + wt * (c1 - c0);
    }
}
