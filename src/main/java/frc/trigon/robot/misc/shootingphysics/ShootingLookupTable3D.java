package frc.trigon.robot.misc.shootingphysics;

import java.io.*;

/**
 * 3D shooting lookup table using trilinear interpolation.
 * Precomputed trajectory solutions indexed by distance and robot velocity.
 * Generated by Python calibration system - loads binary data at runtime.
 */
public class ShootingLookupTable3D {
    private static final int BUFFER_SIZE = 65536;
    private static final int BYTES_PER_DOUBLE = 8;
    private static final int BYTES_PER_MEGABYTE = 1024 * 1024;
    private static final double SYMMETRY_THRESHOLD = 0.0;

    private static int distanceSize, radialSize, tangentialSize;
    private static double distanceMin, distanceMax, distanceStep;
    private static double radialMin, radialMax, tangentialMin, tangentialMax, velocityStep;
    private static double[] velocityData, pitchData, yawData;
    private static boolean isLoaded = false;

    public static void init() {
        try {
            loadFromFile(ShootingCalculationsConstants.SHOOTING_LOOKUP_TABLE_FILEPATH, true);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * @param filepath path to binary lookup table file
     * @param verbose  enable loading progress logs
     */
    public static void loadFromFile(final String filepath, final boolean verbose) throws IOException {
        if (isLoaded) {
            logIfVerbose("ShootingLookupTable3D already loaded, skipping", verbose);
            return;
        }

        validateFileExists(filepath);
        final long startTime = System.currentTimeMillis();

        loadTableData(filepath, verbose);

        isLoaded = true;
        logLoadingComplete(startTime, verbose);
    }

    public static boolean isLoaded() {
        return isLoaded && velocityData != null && velocityData.length > 0;
    }

    /**
     * Uses absolute value of tangential velocity - yaw symmetry is applied separately.
     */
    public static double calculateVelocity(final double distance, final double radialVelocity, final double tangentialVelocity) {
        validateLoaded();
        return interpolate(velocityData, distance, radialVelocity, Math.abs(tangentialVelocity));
    }

    /**
     * Uses absolute value of tangential velocity - yaw symmetry is applied separately.
     */
    public static double calculatePitch(final double distance, final double radialVelocity, final double tangentialVelocity) {
        validateLoaded();
        return interpolate(pitchData, distance, radialVelocity, Math.abs(tangentialVelocity));
    }

    /**
     * Applies yaw symmetry based on tangential velocity sign.
     * Positive tangential velocity uses positive yaw, negative uses negative yaw.
     */
    public static double calculateYaw(final double distance, final double radialVelocity, final double tangentialVelocity) {
        validateLoaded();
        final double yaw = interpolate(yawData, distance, radialVelocity, Math.abs(tangentialVelocity));
        return applyYawSymmetry(yaw, tangentialVelocity);
    }

    private static void validateFileExists(final String filepath) throws IOException {
        final File file = new File(filepath);
        if (!file.exists()) {
            throw new IOException("LUT file not found: " + filepath);
        }
    }

    private static void validateLoaded() {
        if (!isLoaded()) {
            throw new IllegalStateException("ShootingLookupTable3D not loaded!");
        }
    }

    private static void loadTableData(final String filepath, final boolean verbose) throws IOException {
        try (final DataInputStream stream = createInputStream(filepath)) {
            logLoadingStart(filepath, verbose);

            readDimensions(stream);
            readBounds(stream);
            readShootingData(stream, verbose);

        } catch (final IOException e) {
            System.err.println("ERROR loading ShootingLookupTable3D: " + e.getMessage());
            throw e;
        }
    }

    private static DataInputStream createInputStream(final String filepath) throws IOException {
        final FileInputStream fileStream = new FileInputStream(filepath);
        final BufferedInputStream bufferedStream = new BufferedInputStream(fileStream, BUFFER_SIZE);
        return new DataInputStream(bufferedStream);
    }

    private static void readDimensions(final DataInputStream stream) throws IOException {
        distanceSize = stream.readInt();
        radialSize = stream.readInt();
        tangentialSize = stream.readInt();
    }

    private static void readBounds(final DataInputStream stream) throws IOException {
        distanceMin = stream.readDouble();
        distanceMax = stream.readDouble();
        distanceStep = stream.readDouble();
        radialMin = stream.readDouble();
        radialMax = stream.readDouble();
        velocityStep = stream.readDouble();
        tangentialMin = stream.readDouble();
        tangentialMax = tangentialMin + (tangentialSize - 1) * velocityStep;
    }

    private static void readShootingData(final DataInputStream stream, final boolean verbose) throws IOException {
        final int totalElements = calculateTotalElements();

        if (verbose) {
            logGridDimensions(totalElements);
        }

        velocityData = readDoubleArray(stream, totalElements);
        pitchData = readDoubleArray(stream, totalElements);
        yawData = readDoubleArray(stream, totalElements);
    }

    private static double[] readDoubleArray(final DataInputStream stream, final int size) throws IOException {
        final double[] array = new double[size];
        for (int i = 0; i < size; i++) {
            array[i] = stream.readDouble();
        }
        return array;
    }

    /**
     * Performs trilinear interpolation on the 3D grid.
     * Clamps input values to grid bounds to prevent out-of-range lookups.
     */
    private static double interpolate(final double[] data, final double distance, final double radialVelocity, final double tangentialVelocity) {
        final double constrainedDistance = clamp(distance, distanceMin, distanceMax);
        final double constrainedRadial = clamp(radialVelocity, radialMin, radialMax);
        final double constrainedTangential = clamp(tangentialVelocity, tangentialMin, tangentialMax);

        final double distanceIndex = (constrainedDistance - distanceMin) / distanceStep;
        final double radialIndex = (constrainedRadial - radialMin) / velocityStep;
        final double tangentialIndex = (constrainedTangential - tangentialMin) / velocityStep;

        final int d0 = (int) Math.floor(distanceIndex);
        final int d1 = Math.min(d0 + 1, distanceSize - 1);
        final int r0 = (int) Math.floor(radialIndex);
        final int r1 = Math.min(r0 + 1, radialSize - 1);
        final int t0 = (int) Math.floor(tangentialIndex);
        final int t1 = Math.min(t0 + 1, tangentialSize - 1);

        final double distanceWeight = distanceIndex - d0;
        final double radialWeight = radialIndex - r0;
        final double tangentialWeight = tangentialIndex - t0;

        return performTrilinearInterpolation(data, d0, d1, r0, r1, t0, t1, distanceWeight, radialWeight, tangentialWeight);
    }

    private static double performTrilinearInterpolation(
            final double[] data,
            final int d0, final int d1,
            final int r0, final int r1,
            final int t0, final int t1,
            final double distanceWeight,
            final double radialWeight,
            final double tangentialWeight) {

        final double c000 = getValue(data, d0, r0, t0);
        final double c001 = getValue(data, d0, r0, t1);
        final double c010 = getValue(data, d0, r1, t0);
        final double c011 = getValue(data, d0, r1, t1);
        final double c100 = getValue(data, d1, r0, t0);
        final double c101 = getValue(data, d1, r0, t1);
        final double c110 = getValue(data, d1, r1, t0);
        final double c111 = getValue(data, d1, r1, t1);

        final double c00 = lerp(c000, c100, distanceWeight);
        final double c01 = lerp(c001, c101, distanceWeight);
        final double c10 = lerp(c010, c110, distanceWeight);
        final double c11 = lerp(c011, c111, distanceWeight);

        final double c0 = lerp(c00, c10, radialWeight);
        final double c1 = lerp(c01, c11, radialWeight);

        return lerp(c0, c1, tangentialWeight);
    }

    private static double lerp(final double value0, final double value1, final double weight) {
        return value0 + weight * (value1 - value0);
    }

    private static double getValue(final double[] data, final int distanceIndex, final int radialIndex, final int tangentialIndex) {
        final int index = calculateFlatIndex(distanceIndex, radialIndex, tangentialIndex);
        return data[index];
    }

    private static int calculateFlatIndex(final int distanceIndex, final int radialIndex, final int tangentialIndex) {
        return distanceIndex * (radialSize * tangentialSize) + radialIndex * tangentialSize + tangentialIndex;
    }

    private static double clamp(final double value, final double min, final double max) {
        return Math.max(min, Math.min(value, max));
    }

    private static double applyYawSymmetry(final double yaw, final double tangentialVelocity) {
        return tangentialVelocity >= SYMMETRY_THRESHOLD ? yaw : -yaw;
    }

    private static int calculateTotalElements() {
        return distanceSize * radialSize * tangentialSize;
    }

    private static void logLoadingStart(final String filepath, final boolean verbose) {
        if (!verbose) return;

        final File file = new File(filepath);
        System.out.println("Loading ShootingLookupTable3D from: " + filepath);
        System.out.println("  File size: " + file.length() / BYTES_PER_MEGABYTE + " MB");
    }

    private static void logGridDimensions(final int totalElements) {
        System.out.println("  Grid: " + distanceSize + " × " + radialSize + " × " + tangentialSize + " = " + totalElements + " elements");
    }

    private static void logLoadingComplete(final long startTime, final boolean verbose) {
        if (!verbose) return;

        final long elapsedMs = System.currentTimeMillis() - startTime;
        final int memoryMB = calculateTotalElements() * 3 * BYTES_PER_DOUBLE / BYTES_PER_MEGABYTE;

        System.out.println("[SUCCESS] ShootingLookupTable3D loaded in " + elapsedMs + "ms");
        System.out.println("  Memory: " + memoryMB + " MB");
    }

    private static void logIfVerbose(final String message, final boolean verbose) {
        if (verbose) {
            System.out.println(message);
        }
    }
}